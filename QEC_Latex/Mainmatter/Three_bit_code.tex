\chapter{Quantum error correction codes}
This chapter is the focus of my thesis, and aims to introduce the reader into the field of quantum error correction. 
In these sections several different procedures and some of the most important error correction codes will be described.  


\section{No-Cloning theorem}
In classical communication we can copy a bit without any problem. Copying the information is one of the basic strategies for the classical error correction code: we increase the reliability of the code and then if a bit has been flipped, through a majority vote we can restore the information.  

Unfortunately, in quantum mechanics, we are not allowed to copy an unknown quantum state. This is due to the No-Cloning theorem \cite{cloning}, which states that it is not possible to copy an arbitrary pure quantum state into another.
The impossibility to copy an arbitrary quantum state means that there is no unitary transformation that can copy an arbitrary state from system A to the system B:
\begin{theorem}
There is no unitary operator $U$ on $\mathcal{H} \otimes \mathcal{H}$ such that for all normalised states $|\psi\rangle_{A}$ and $|s\rangle_{B}$ in $\mathcal{H}$
$$
U\left(|\psi\rangle_{A}|s\rangle_{B}\right)=e^{i \alpha(\psi, s)}|\psi\rangle_{A}|\psi\rangle_{B},
$$
for some real number $\alpha$ depending on $\psi$ and $s$.
\end{theorem}



The no-cloning theorem states that it is not possible to perfectly clone the state but as shown in \cite{buzek1998universal} it is possible to get an optimal copy of a state with certain fidelity. In addition, a different proof can be given showing that the No-cloning theorem works with mixed states as well; in this case, the theorem is often known as the No-broadcasting theorem.
The no-cloning theorem prevents the use of certain classical error correction techniques on quantum states. For example, backup copies of a state in the middle of quantum computation cannot be created and used for correcting subsequent errors.
Hence, we cannot use the classical "copy and paste" tactic in quantum error correction codes to protect our information, but this does not mean that we have to get rid of the classical error correction theory; indeed it is very helpful to build reliable code with minimum effort, for instance, the CSS codes.
Instead, in quantum error correction, another strategy is adopted: the information is not copied but is spread out on multiple qubits. 


One of the simplest and emblematic quantum error-correcting codes that shows this property is the 3-qubit code, although it can correct only a bit flip ($\sigma_X$) error, it is still a good starting point for more complicated algorithms.


\section{3-qubit error correction code}
% Unfortunately with quantum systems we cannot copy an unknow state, like the non-cloning theorem states. In other words, we cannot copy the same information about the system like in the classical case, where if we wanted to send a bit, we could have copied. 
% Instead, if we deal with quantum systems, we have to spread the information about the system among some qubits.
% Hence, in order to protect the original information we need to entangled it with some qubit. 

% The most basic quantum error correction code is the 3-Qubit code. This algorithm protects the information along a noisy channel that can affect the qubits with bit-flip error. However, before starting we need to make some assumptions about the noise: 
% \begin{itemize}
%     \item The noise 
%     \item The probability that the noise might flip a qubit  is ($p<\frac{1}{2}$)\footnote{This assumption is important when a fidelity check}
% \end{itemize}
Just as every communication problem in literature typically starts with Alice and Bob I will do the same here.

Suppose that Alice wishes to transmit a qubit through a noisy channel to Bob, which leaves the qubit untouched with probability $1-p$, and flips the qubit with probability $p$ introducing a bit-flip $X$ error.

Before analysing the algorithm we need to make some assumptions about the noise\cite{SteaneTut}: \begin{itemize}
    \item it acts on each qubit independently,
    \item it is identically distributed on each qubit,
    \item the quantum gates in the encoding, recovery and decoding procedure are not subjected to errors,
    \item the error probability $p$ has to be less than $\frac{1}{2}$ to be able to correct the error.
    \label{item: noise}
\end{itemize}

The quantum error correction method is summarised in figure \ref{fig:3fq}.
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Mainmatter/images/3bitflipcode.png}
    \caption{Circuit for the 3 bit-flip error correction code, built with CNOT gates, which allows for the correction of one X error on the encoded state. 
    The thin horizontal lines are qubits, while the thick line indicates classical bits. 
    All the different stages of the 3 bit-flip code are separated from grey barriers. From left to right: 1. Initialise the state, 2.Encoding procedure, 3.Error, 4. Syndrome measurement, 5. Store results in a classical register 6. Error correction, 7.Decoding. }
    \label{fig:3fq}
\end{figure}

The original quantum information that we want to protect can be written without loss of generality as $\ket{\psi} = \alpha\ket{0}+\beta\ket{1}$.
As previously said, one might be tempted to clone the information like in the classical binary repetition code, but the no-cloning theorem prevents us from applying an operation that maps $\ket{\psi} \to \ket{\psi}\ket{\psi}\ket{\psi}$, showing that the classical idea cannot be directly taken over.
Instead, we can encode our qubit with other two qubits initially in the state $\ket{0}$. First, we initialise the device in the state $\ket{\psi} \to  (\alpha\ket{0}+\beta\ket{1})\otimes \ket{0} \otimes \ket{0}$. Then we apply two CNOT gates as shown in figure \ref{fig:3fq}, and encode the qubits in the following way: 
\begin{equation*}
  \alpha\ket{000}+\beta\ket{100} \to \alpha\ket{000}+\beta\ket{111} := \ket{\psi}_L,
\end{equation*}
where we use the subscript $L$ to denote that the final encoded state lives in the logical two-dimensional subspace spanned by $\{\ket{0}_L = \ket{000} , \ket{1}_L = \ket{111}\}$:
$$
|\psi\rangle_{L} \in \mathcal{C}=\operatorname{span}\{|000\rangle,|111\rangle\},
$$
where $\mathcal{C}$ is called the codespace and its elements are the codewords.% We can also write the density operator that describe the system: $\rho=\ket{\psi_L}\bra{\psi_L}$.



Then the logical state $\ket{\psi}_L$ is sent through the channel, and an error may occur. 


Notice that three individual bit flips are required to take $\ket{0}_L \leftrightarrow \ket{1}_L$. Hence if we assume $\ket{\psi} = \ket{0}_L$, a single bit-flip on any qubit leaves the final state closer to $\ket{0}_L$ than $\ket{1}_L$. One can quantify this observation using the code distance $d$, which defines the number of errors $t$ that can be corrected, as $t=\floor{\frac{d-1}{2}}$. In short, $d$ represent the distance between two codewords, in this case, $d=3$ because only a weight 3-error, such as $\Tilde{X}=X^{\otimes 3}$, which maps $\ket{0}_L \to \ket{1}_L$. Using the previous notation a code with distance 3 can correct 1 error, but we will give a more in-depth explanation for the code distance and the number of correctable errors in section \ref{sec:distance}.



%The noise action on the qubits can be thought of as a set of Kraus operators which multiply the state of the system with some probabilities. We define an error set for the bit-flip noise: $\mathcal{E}=\left\{I,X^1,X^2,X^3\right\}$ as a set of operators proportional to Kraus operators. 
%The bit-flip noise acting on the qubit (i) can be written as: 
%\begin{equation*}
 %   \mathcal{E}^i(\rho) = (1-p)\rho +p X^i \rho X^i 
%\end{equation*}
%Generally, at least one of these operators (usually $\left.E_{0}\right)$ is taken to be the identity $I$ (at least to a good approximation), which corresponds to no error occurring, while the others represent possible errors. 
%Since the noise acts independently on each of the 3 qubits: 
%\begin{equation*}
 %   \mathcal{E}_{noise}(\rho)=\mathcal{E}^3(\mathcal{E}^2(\mathcal{E}^1(\rho)))
%\end{equation*} 
After the noisy channel, the outcome state is one of the following:

\begin{table}[h!]
    \centering
    \begin{tabular}{cc}
        \text { State } & \text { probability} \\
        \hline
$\alpha|000\rangle+\beta|111\rangle$ & $(1-p)^{3}$ \\
$\alpha|100\rangle+\beta|011\rangle$ & $p(1-p)^{2}$ \\
$\alpha|010\rangle+\beta|101\rangle$ & $p(1-p)^{2}$ \\
$\alpha|001\rangle+\beta|110\rangle$ & $p(1-p)^{2}$ \\
    \end{tabular}
    \caption{This table shows the possible state outcomes after the noise}
    \label{tab:error_prob}
\end{table}

% \begin{equation}
% \begin{array}{ll}
% \text { State } & \text { probability} \\
% \alpha|000\rangle+\beta|111\rangle & (1-p)^{3} \\
% \alpha|100\rangle+\beta|011\rangle & p(1-p)^{2} \\
% \alpha|010\rangle+\beta|101\rangle & p(1-p)^{2} \\
% \alpha|001\rangle+\beta|110\rangle & p(1-p)^{2} \\
% % a|110\rangle+b|001\rangle & p^{2}(1-p) \\
% % a|101\rangle+b|010\rangle & p^{2}(1-p) \\
% % a|011\rangle+b|100\rangle & p^{2}(1-p) \\
% % a|111\rangle+b|000\rangle & p^{3}
% \end{array}
% \label{eq:error_prob}
% \end{equation}
We can focus on the case where only one physical qubit has been flipped, and ignore all the errors that flipped 2 or more qubits; in fact, the code will not be able to correct all of them; the probability for them to occur is of higher-order $O(p^2)$.


Classically, single bit-flip errors are corrected by measuring the three bits and taking a majority vote. Here, this is not possible, since measuring the qubits would project the system into one of the basis states with probability $|\alpha|^{2}$ or $|\beta|^{2}$,
destroying the superposition state that we are trying to protect. 

There is a two stage error-correction procedure which can be used to recover the correct quantum state without loosing the information: detect the error and correct it.  


In order to detect the error, we have to perform a measurement that reveals the error without revealing any information about the encoded state.
Error detection measurements are called syndrome measurements and the outcomes are called syndromes. 

In the quantum 3 bit-flip code one possible way to detect the error is to measure the correlation between two qubits, using two  commuting observables $Z_1 Z_2$ and $Z_2 Z_3$ with eigenvalues $\pm 1$.

%All four states are mutually orthogonal, hence they lie in orthogonal subspaces. Therefore, there is a quantum measurement that will tell which of these four subspaces the state is in without projecting onto a basis state and thereby destroying the superposition.

%We find that the outcomes of these syndrome measurements can detect and distinguish all single-qubit bit-flips, which can then be corrected. 


As shown in figure \ref{fig:3fq} this involves the use of two more qubits, these are called ancilla qubits.
The basic idea is to extract the syndrome performing two parity checks with the commuting observables $Z_1 Z_2$ and $Z_2 Z_3$ on the data block, and store the information in the ancilla qubits. 
The two ancillas are then coupled to the data block as shown in figure \ref{fig:3fq}, using CNOT gates. 
We are left with: 
\renewcommand{\arraystretch}{1.5}
\begin{table}[h!]
    \centering
    \begin{tabular}{cc}
         \text{Error Location }& \text{Final State}, $|data\rangle|ancilla\rangle$ \\
         \hline
         \text{No Error} & $(\alpha|000\rangle+\beta|111\rangle)|00\rangle$ \\
\text{Qubit 1} & $(\alpha|100\rangle+\beta|011\rangle)|10\rangle$ \\
\text{Qubit 2} & $(\alpha|010\rangle+\beta|101\rangle)|11\rangle$ \\
\text{Qubit 3} & $(\alpha|001\rangle+\beta|110\rangle)|01\rangle$ 
    \end{tabular}
    \caption{This table shows which error is associated with the ancillae }
    \label{tab:ancilla3}
\end{table}


% \begin{equation*}
%     \begin{array}{cc}
%          \text{Error Location }& \text{Final State}, |data\rangle|ancilla\rangle \\
%          \text{No Error} & (\alpha|000\rangle+\beta|111\rangle)|00\rangle \\
% \text{Qubit 1} & (\alpha|100\rangle+\beta|011\rangle)|10\rangle \\
% \text{Qubit 2} & (\alpha|010\rangle+\beta|101\rangle)|11\rangle \\
% \text{Qubit 3} & (\alpha|001\rangle+\beta|110\rangle)|01\rangle 
%     \end{array}
% \end{equation*}
A measurement of the ancillas reveals where (or if) an error has occurred, without directly measuring any of the data qubits.

Then, we use the value of the error syndrome to identify what procedure to use to recover the initial state:
% \begin{equation*}
%     \begin{array}{ccc}
%         \text{Syndrome measurement:}
%         (Z_1Z_2,Z_2Z_3) & \text{Ancilla state}& \text{Correction}\\
%          (+1,+1) & |00\rangle & \text{Clean state, no correction needed }\\
% (-1,+1) & |10\rangle & \text{Bit flip on qubit 1} \\
% (-1,-1) & |11\rangle & \text{Bit flip on qubit 2}\\
% (+1,-1) & |01\rangle  & \text{Bit flip on qubit 3}
%     \end{array}
% \end{equation*}
\renewcommand{\arraystretch}{1.5}
\begin{table}[h!]
    \centering
    \begin{tabular}{ccc}
         \text{Syndrome measurement:}
        $(Z_1Z_2,Z_2Z_3)$ & \text{Ancilla state}& \text{Correction}\\
        \hline
         $(+1,+1)$ & $|00\rangle$ & \text{Clean state, no correction needed }\\
$(-1,+1)$ & $|10\rangle$ & \text{Bit flip on qubit 1} \\
$(-1,-1)$ & $|11\rangle$ & \text{Bit flip on qubit 2}\\
$(+1,-1)$ & $|01\rangle$  & \text{Bit flip on qubit 3}
    \end{tabular}
    \caption{This table shows which error correction should be applied after a specific ancillae state and syndrome measurement. }
    \label{tab:ancilla_and_correction}
\end{table}
\renewcommand{\arraystretch}{1.2}
This bit-flip code has a correctable error set with four error operators: $\left\{I, X_{1}, X_{2}, X_{3}\right\}$. However, the full error set of this error model contained eight error operators. The three errors of weight 2 and one error of weight-3 are uncorrectable errors. They produce states in the same four sub-spaces above, and it is easy to see that in the case of those high-weight errors the correction procedure will produce the erroneous state $\left|\psi_{L}^{\prime}\right\rangle=\alpha|111\rangle+\beta|000\rangle .$ Moreover, the weight 3 error will not even be recognized as an error: it is an undetectable error. This is a general property of QECCs: no QECC can correct every possible error. (This is also true of classical error correcting codes.) In practice, the goal is to choose a code that can correct the most likely errors.
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Mainmatter/images/3phaseflipcode.png}
    \caption{Circuit for the 3 phase flip error correction code, built with CNOT gates, which allows for the correction of one Z error on the encoded state. 
    The thin horizontal lines are qubits, while the thick line indicates classical bits. 
    All the different stages of the 3 bit-flip code are separated from grey barriers. From left to right: 1. Initialise the state, 2.Encoding procedure and change computational basis, 3.Error and immediately after applying the Hadamard gate we get back to the original computational basis, 4. Syndrome measurement, 5. Store results in a classical register 6. Error correction, 7.Decoding.}
    \label{fig:3phfc}
\end{figure}

Similarly, we can implement also the phase flip error code. In fact, a phase flip error in the computational basis ($\ket{0},\ket{1}$) can be seen as a bit flip in a new set of basis ($\ket{+},\ket{-}$), as shown in section \ref{sec:qgate}.

This suggests using the states $\ket{+},\ket{-}$ to create the logical encoded qubits: 
\begin{equation*}
    \begin{array}{c}
         \ket{0}_L=\ket{+++} ,\\
          \ket{1}_L=\ket{---},
    \end{array}
\end{equation*} these are the zero and the one states for protection against phase flip errors. 
To change basis in quantum circuit we can apply an Hadamard gate at appropriate points in the procedure.
The 3 phase-flip circuit is shown in figure \ref{fig:3phfc}

%Then all the operations needed for error-correction are performed just as for the bit flip channel, but with respect to the new basis $\ket{+},\ket{-}$


We can improve our error analysis calculating the fidelity of this quantum error correction code, giving a measure of how reliable is this code against specific type of errors.
To calculate the fidelity is better to use the density matrix formalism, recalling the fact that the fidelity between a pure and a mixed state is given by :$ \mathcal{F}(\ket{\psi},\rho) = \bra{\psi}\rho\ket{\psi}$.
The object of quantum error-correction is to increase the fidelity with which quantum information is stored (or communicated) up near the maximum possible fidelity of one. Let’s compare the minimum fidelity achieved by the three qubit bit flip code with the fidelity when no error-correction is performed.
Suppose the quantum state of interest is $\ket{\psi}$ .
Without using the error-correcting code the state of the qubit after being sent through the channel is: 
\begin{equation*}
    \rho = (1-p)\ket{\psi}\bra{\psi} + p X\ket{\psi}\bra{\psi}X.
\end{equation*}
Then the fidelity is given by
$$
F=\langle\psi|\rho| \psi\rangle=(1-p)+p\langle\psi|X| \psi\rangle\langle\psi|X| \psi\rangle.
$$
Then the minimum fidelity is $F=1-p$ (No error correction code applied). %Suppose the three qubit error correcting code is used to protect the state $|\psi\rangle=a\left|0_{L}\right\rangle+b\left|1_{L}\right\rangle.$ 
On the other hand, the state after both the noise and error-correction is:
$$
\rho=\left[(1-p)^{3}+3 p(1-p)^{2}\right]|\psi\rangle\langle\psi|.
$$
The omitted terms represent contributions from bit flips on two or three qubits. All the omitted terms are positive operators, so the fidelity we calculate will be a lower bound on the true fidelity. We see that $F=\langle\psi|\rho| \psi\rangle \geq (1-p)^{3}+3 p(1-p)^{2}$. 
Since the fidelity is at least $1-3 p^{2}+2 p^{3}$, so the fidelity is improved provided $p <1 / 2$, as it is possible to see in figure \ref{fig:fidelity3qbit}.


\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.07]{Mainmatter/images/fidelity.png}
    \caption{In red the fidelity with the error correction procedure, in blue the fidelity without error correction}%( Currently this image is from wikipedia, but i will replace it with mine once I will do the computational part)}
    \label{fig:fidelity3qbit}
\end{figure}


\subsection{Simulation of the 3 bit and phase flip code}
In this subsection, I will show the computational results of the circuits showed in figures \ref{fig:3fq} and \ref{fig:3phfc}. I implemented these codes in python, in particularly using the qiskit library \cite{Qiskit}. My codes can be consulted in my \href{https://github.com/AlexsashaV4/bachelor_thesis_QEC.git}{GitHub}.
\subsubsection*{3 bit-flip code}

First, I prepared the "information qubit" ($q_0$) in the initial state\footnote{This choice is totally arbitrary, I chose this one only to emphasise more the results}: \begin{equation}
    \ket{\psi}=\frac{1}{\sqrt{3}}\ket{0} + \sqrt{\frac{2}{3}} \ket{1},
    \label{eq:initialstate}
\end{equation}
where the generic $\alpha$ is replaced by $\frac{1}{\sqrt{3}}$ and $\beta$ by $\sqrt{\frac{2}{3}}$.


I encoded this qubit as shown in the circuit in figure \ref{fig:3fq} creating the encoded state: $\ket{\psi}=\frac{1}{\sqrt{3}}\ket{000} + \sqrt{\frac{2}{3}} \ket{111}$. 

Then, a faulty gate that simulates the bit-flip error channel was created, in such a way that satisfies the noise conditions written at the beginning of section \ref{item: noise}.

In addition, I set the error probability to $p=0.1$, and ran the simulations with $10^5$ shots \footnote{This is because each time that we do a measurement, a circuit simulation the state collapse, so to get the probability i need to simulate the same circuit more times}.

To illustrate that the faulty gate acts as an error channel, projecting the encoded state into other perpendicular states, we can measure the outcomes just after the faulty gate. We should get the same results as in table \ref{tab:error_prob}. Therefore, from the measurement we should expect to find the initial state ($33\%$ of the time in $\ket{000}$ and around $67\%$ of the time in $\ket{111}$) with probability $p_{no  err}=(1-p)^3=0.729$. In fact, as it is possible to see from figure \ref{fig:justaftererror}, if we sum up the probability of $\ket{000}$ and $\ket{111}$ we get $0.737$ which is close to the expectation.


Instead the probability that an error has occurred on the initial state is $p(1-p)^2 = 0.081$. This means that we should get a different state from the initial one with probability $p(1-p)^2 = 0.081$, but with the same amplitudes ($\alpha$,$\beta$) of the initial one. Let us consider the case where the bit flip error occurred on a qubit ($\ket{\psi}_F = \alpha|100\rangle+\beta|011\rangle$), hence we should measure this state with probability $p(1-p)^2 = 0.081$. As before, it is possible to see this from figure \ref{fig:justaftererror}. In fact, if we sum up the probability of $\ket{100}$ and $\ket{011}$ we get $0.084$ which is close to what we expected.
The small fluctuation around the expected values are stochastic errors and because a $O(p^2)$ error occurred.
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.7]{Mainmatter/images/Measure_just_after.png}
    \caption{This bar graph shows the outcome state and their probabilities after a noisy bit-flip gate. On the x axes there are the possible measurement outcomes, on the y axes the associated probability of measuring them. Along the x axes each histogram bar is labelled with the state. The displayed qubits for each bar are written in the following order: $"q_2 q_1 q_0"$. For example, the second bar shows the probability of $"q_2 q_1 q_0"=\ket{001}$.}
    \label{fig:justaftererror}
\end{figure}

Now that we are sure that the noise works as expected, we should look at the recovery and the decoding. The recovery needs two ancillae (in figure \ref{fig:3fq} are labelled with "auxiliary"), which detect the error without collapsing the information. Thank the ancilla results we can correct the error. 
The simulation results at the end of the circuit are shown in figure \ref{fig:outcome_bitflipres}.

\begin{figure}[h!]
    \includegraphics[width=\textwidth]{Mainmatter/images/outcome3bitflip.png}
    \caption{This bar graph shows the outcome state and their probabilities after the recovery and the decoding procedures. On the x-axes, there are the possible measurement outcomes with the ancillae that indicate which error occurred, on the y-axes the associated probability. Along the x-axes, each histogram bar is labelled with the state. The displayed qubits for each bar are written in the following order: $"q_2 q_1 q_0 \quad a_1a_0"$, where $a_1 a_0$ indicates the ancilla qubit. Is it possible to see the $q_0$ state has been recovered if an error occurred.}
    \label{fig:outcome_bitflipres}
\end{figure}
From the results, is possible to see that all the errors have been recovered\footnote{To be precise the errors of higher-order ($p^2$) have been corrected badly, but they are negligible compared to the order of $p$ }. The results are displayed as follow $"q_2 q_1 q_0 \quad a_1 a_0"$, with the ancilla measurements $"a_1 a_0"$ . In figure \ref{fig:outcome_bitflipres} we see that we recovered successfully the initial state. If we sum up all the probabilities to find the "information qubit" ($q_0$) in $\ket{0}$, independently of the occurred error, we get $0.336$ which is very close to $0.333$ as expected. The same works for the probability to find the qubit ($q_0$) in $\ket{1}$, which for the initial state was approximately $0.667\%$, here we get $0.663$. 



\newpage
\subsubsection*{3 phase flip code}

Similarly, I implemented the 3 phase flip code. 
The set-up is the same as the 3 bit-flip code, but I applied a Hadamard gate before and after the faulty gate. 
Recalling that the Hadamard gate changes computational basis, then a Z error may occur, and if we want to see the Z error as a bit-flip we need to change basis again, i.e applying a Hadamard gate again.
The results just after the faulty gate are shown in figure \ref{fig:Seno200Hz}. 
and the results after the recovery are shown in figure \ref{fig:Seno900Hz}
\begin{figure}[h!]
\begin{minipage}[t]{0.49\textwidth}
\includegraphics[width=\linewidth]{Mainmatter/images/Result_phase_justafter.png}
\caption{This bar graph shows the outcome state and their probabilities after a noisy phase-flip gate between two Hadamards, this allows us to change bases and interpret the phase error as a bit-flip error. On the x axes there are the possible measurement outcomes, on the y axes the associated probability of measuring them. Along the x axes each histogram bar is labelled with three qubits. The displayed qubits for each bar are written in the following order: $"q_2 q_1 q_0"$. For example, the second bar shows the probability of $"q_2 q_1 q_0"=\ket{001}$.}
\label{fig:Seno200Hz}
\end{minipage}
\hspace{0.65cm}
\begin{minipage}[t]{0.6\textwidth}
\includegraphics[width=\linewidth]{Mainmatter/images/3Phase_Results.png}
\caption{This bar graph shows the outcome state and their probabilities after the recovery and the decoding procedures. On the x-axes, there are the possible measurement outcomes with the ancillae that indicate which error occurred, on the y-axes the associated probability. Along the x-axes, each histogram bar is labelled with the state. The displayed qubits for each bar are written in the following order: $"q_2 q_1 q_0 \quad a_1a_0"$, where $a_1 a_0$ indicates the ancilla qubit. Is it possible to see the $q_0$ state has been recovered if an error occurred.}
\label{fig:Seno900Hz}
\end{minipage}
\end{figure}

The considerations and the analysis done in the bit-flip code paragraph are analogous for the phase-flip code. The main difference between these two codes is the encoding procedure, as it is possible to see in \ref{fig:3phfc}, which implements a change of basis in such a way that a Z error can be considered as a bit-flip error in the new basis and then the error is translated in the computational basis using the Hadamards again. In fact: $HZH=X$, simulating a bit-flip, and the recovery follows as the 3 bitflip code. 







\section{Condition for quantum error correction}
In the previous sections we saw how the noise impact on the system, now we are looking for some recovery procedure to correct an eventual error. However, there are some conditions to be satisfied in order to create a quantum error correctin code. These conditions are called Knill-Laflamme conditions \cite{Knill_2000}.



In any code, we must never confuse the logical encoded qubits $|0\rangle_L$ with $|1\rangle_L$, even in the presence of errors.
Suppose, in fact, that two errors $E_a$ and $E_b$ map the initially orthogonal codewords $\ket{0}_L \to E_a\ket{0}_L$ and $\ket{1}_L \to E_b \ket{1}_L$ such that the faulty states have non-zero overlap : $_L\bra{1}E_b^{\dagger}E_a\ket{0}_L \neq 0$. 
When trying to detect the error that happened it is possible (non-zero probability) that we can not distinguish between the events where the system started. In other words, no measurement can decide with certainty whether the initial state was $\ket{0}_L$ or $\ket{1}_L$
If two codewords are orthogonal, and they are acted upon by correctable errors, the result will remain orthogonal. This is a necessary condition given a set $\mathcal{E}$ of correctable errors \footnote{A set $\mathcal{E}$ of correctable errors exist an operator $\mathcal{R}$ such that $\ket{\psi} = \mathcal{R}E\ket{\psi} \quad \forall E \in \mathcal{E}$}:
\begin{equation*}
    \bra{\psi_i}E_b^{\dagger}E_a\ket{\psi_j} = 0 \quad \forall E \in \mathcal{E} \text{   and   } \forall \ket{\psi_i} \neq \ket{\psi_j} \in \mathcal{C},
\end{equation*}
where $\mathcal{C}$ indicate the codespace.

This is not enough, another condition is required:
\begin{equation*}
    \bra{\psi_i}E_b^{\dagger}E_a\ket{\psi_i} = \bra{\psi_j}E_b^{\dagger}E_a\ket{\psi_j} \quad \forall E \in \mathcal{E} \text{   and   } \forall \ket{\psi_i},\ket{\psi_j} \in \mathcal{C}.
\end{equation*}
This second condition is that the outcome of the syndrome measurement must not give any information about the codewords, otherwise the superposition state will collapse. 
whatever the state encoded in the subspace is, errors occurring on this state must not reveal anything about the state (otherwise we could learn something about the state, thereby destroying quantum information). In other words, the 'symmetric' inner product cannot depend on what exactly the 'current' codeword.
This two conditions, called also Knill-Lafflame conditions, can be combined in one yielding to the following theorem \cite{Knill_2000}: 
 \begin{theorem}
 Suppose $\mathcal{E}$ is a linear space of errors acting on the Hilbert space
$\mathcal{H}$. Then a subspace $C$ of $\mathcal{H}$ forms a quantum error-correcting code correcting the errors $\mathcal{E}$ iff:
\begin{equation}
\bra{\psi_j}E_b^{\dagger}E_a\ket{\psi_i} = C_{a b}\delta_{ij},
\label{eq:conderrorcorrect}
\end{equation}
for all $E \in \mathcal{E}$. 
\end{theorem}

 The matrix's elements $C_{a b}$ do not depend on the codewords $|\psi\rangle$. %Since $\bra{\psi_i}E_b^{\dagger}E_a\ket{\psi_j}=\left(\bra{\psi_j}E_a^{\dagger}E_b\ket{\psi_i}\right)^{\dagger}$ for all $i$, we may write $C_{a b}$ as a Hermitian matrix.
If $C_{a b}$ has maximal rank, we say that the code is non-degenerate. Otherwise, if $C_{a b}$ has non-maximal rank, we say that the code is degenerate. A non-degenerate code refers to the case that each error in the set $\mathcal{E}_{c}$ corresponds to a unique syndrome, while in the case of degenerate code, there exist two errors in $\mathcal{E}_{c}$ whose syndromes are the same. For example, in the 9-qubit code is a degenerate code since the errors $Z_{1}, Z_{2}$, and $Z_{3}$ all share the same syndromes. Anyhow, for that case, applying a recovery $Z$ operation on any of the error qubits that share the same syndrome can correct these errors.






\section{Stabilizer formalism}
In quantum error correction codes the description of quantum states becomes a difficult task when the number of qubits starts rising, all the possible quantum states where the information can be projected by the noise grow exponentially in the number of qubits ($2^n$, where $n$ is the number of physical qubits).
The stabilizer formalism is a powerful tool that allows us to make general rules to implement preparation circuits, correction circuits and fault-tolerant logical gate operations once the stabilizer structure of the code is specified \cite{DanielGottesman} \cite{gottesman1997stabilizer}.


For example, the three-qubits code works by de-localising the information. The resultant logical state is then encoded in a two-dimensional subspace (the codespace $\mathcal{C}$) of the expanded Hilbert space. If an X-error occurs, the logical state is rotated to an orthogonal error space. This is an event that can be detected via measurements of two commuting operators (stabilizers) and the results are saved in some ancilla qubits, in the case of the three-qubit code the generators of the stabilizer group were $\{Z_1 Z_2 I, I Z_2 Z_3 \}$. 
%More in general the stabilizer formalism use the following scheme: 


%Usually a code is identified with this notation $[[n, k, d]]$ stabilizer codes, where $n$ is the total number of qubits, $k$ is the number of logical qubits and $d$ is the code distance. For instance the the three-qubit has $[[3,1,3]]$

%The advantage of entanglement-assisted stabilizer codes is that the sender can exploit the error-correcting properties of an arbitrary set of Pauli operators.




Consider $\mathcal{S}=\{M\}$ to be a set of commuting error operators ($[M_i,M_j]=0 \quad \forall i,j$), this set is called Abelian. Since the operators all commute, they  have simultaneous eigenstates.
Let $\mathcal{C}=\{|u\rangle\}$ be an orthonormal set of simultaneous eigenstates all having eigenvalue $+1$:
\begin{equation}
M|u\rangle=|u\rangle \quad \forall u \in \mathcal{C}, \quad \forall M \in \mathcal{S}.
\label{eq:stab}
\end{equation}
The set $\mathcal{C}$ is called codespace and its elements $|u\rangle$ are called code vectors or quantum codewords. 
A general state in the codespace is an encoded state or logical state, and it can be expressed as a superposition of the code vectors:
$$
|\psi\rangle_{L}=\sum_{u \in \mathcal{C}} a_{u}|u\rangle,
$$ 
%Furthermore, $\mathcal{C}$ has $2^{k}$ members, since its members span a $2^{k}$ dimensional subspace of the $2^{n}$ dimensional Hilbert space of the whole system.
%On the other side, $\mathcal{S}$ is its stabilizer, its size is $2^{m}$, and it is spanned by $m =n-k$ linearly independent members of $\mathcal{S}$, where $n$ is the number of physical qubits and $k$ is the number of logical or encoded qubits.

%At this stage, the data previously stored solely in $\ket{\psi}$ is distributed across the expanded Hilbert space. 
On the other hand, a suitable stabilizer set of commuting operators acting on a single qubit can be a subgroup of the Pauli group:
$$
\mathcal{P}=\left\{\pm I, \pm i I, \pm X, \pm i X, \pm Y, \pm i Y, \pm Z, \pm i Z\right\}.
$$

This set of matrices forms a group under the operation of matrix multiplication. The reason why that the multiplicative factor $\pm 1 $ and $\pm i$ are included is to ensure that $\mathcal{P}$ is closed under multiplication, thus forming a legitimate group. 
We can also generalize the concept of stabilizers for a system of multiple qubits. 
Given $n$ qubits a stabilizer set is a subgroup of the Pauli group $\mathcal{P}_n$, which is created by taking the $n$-fold tensor product of $\mathcal{P}$, i.e.
$$
\begin{aligned}
\mathcal{P}_{n} =\mathcal{P}^{\otimes n}
=\left\{\pm I, \pm i I, \pm X, \pm i X, \pm Y, \pm i Y, \pm Z, \pm i Z\right\}^{\otimes n}.
\end{aligned}
$$

We can now define stabilizers more precisely: a subgroup $\mathcal{S} \subseteq \mathcal{P}_{n}$ is called stabilizer group of a system of $n$ qubits with $k$ logical qubits, and $\mathcal{C}$ is the vector space stabilized by $\mathcal{S}$.  

One feature of the stabilizer codes is that we can start from a stabilizer set and then deduct a codeword.
A perfect example, (again), is the three-qubit code ($n=3$), we can start defining a stabilizer set $\mathcal{S} \equiv \{III,Z_1Z_2I,$ $IZ_2Z_3,Z_1IZ_3\}$. 
The subspace fixed by the operator $Z_1Z_2I$ is spanned by $|000\rangle$, $|001\rangle,|110\rangle$ and $|111\rangle$, and the subspace fixed by $IZ_{2} Z_{3}$ is spanned by $|000\rangle,|100\rangle,|011\rangle$ and $|111\rangle$. 
The elements $|000\rangle$ and $|111\rangle$ are common to both these lists. Consequently, $\mathcal{C}$ must be the sub-space spanned by the states $|000\rangle$ and $|111\rangle$. 
Looking at this example we noticed that the sub-spaces have been stabilized by only two of the operators in $\mathcal{S}$.
In fact, mathematically a group can be described by its generators.
A set of elements $\{g1,...,gl\}$ in a group $G$ is said to generate the group $G$ if every element of $G$ can be written as a product of some of its elements. In the example $\mathcal{S}= \langle Z_1Z_2I,IZ_2Z_3\rangle$ as $Z_1IZ_3 = (Z_1Z_2I)(IZ_2Z_3)$ and $III = (Z_1Z_2I)^2$.
The great advantage of using generators to describe groups is that they provide a compact means of describing the group.
Nevertheless, not just any subgroup $\mathcal{S}$ of the Pauli group can be used as the stabilizer for a nontrivial vector space. For example, consider the subgroup of $\mathcal{P}_{1}$ consisting of $\{\pm I, \pm X\}$, the only solution to $(-I)|\psi\rangle=|\psi\rangle$ is $|\psi\rangle=0$, and thus $\{\pm I, \pm X\}$ is the stabilizer for the vector space with only the null vector. Hence, two conditions are necessary in order not to span a trivial vector space :
\begin{enumerate}
    \item the stabilizer subgroup is Abelian ( i.e the elements of $\mathcal{S}$ commute)
    \item $-I$ and $-iI$ are not an element of the stabilizer set.
\end{enumerate}  

 
One can show that if a stabilizer group $\mathcal{S}$ has $n-k$ independent generators, then $\operatorname{dim}[\mathcal{S}]=2^{n-k}$ and $\operatorname{dim}\left[\mathcal{C}\right]=2^{k}$, where $n$ indicates the number of physical qubits utilized and $k$ the logical qubits represented \cite{gottesman1997stabilizer} \cite{brun2019quantum}. 
Whenever possible, $\mathcal{S}$ is typically represented through its independent generators $\mathcal{S}=\langle g_{1}, g_{2}, \ldots, g_{n-k}\rangle$.





To understand how stabilizer codes detect and correct errors it is helpful to assume that the correctable set of errors $\mathcal{E}=\{E\}$ consist of operators from the Pauli group. 



Suppose that an error operator $E$ acts on the state. It anticommutes with some of the stabilizer generators, and commutes with others\footnote{Commute: $[M,E] = ME-EM = 0 $.
Anticommute: $\{M,E\}=ME+EM=0$}.
\begin{equation}
    M(E\ket{\psi}_L) = \pm EM\ket{\psi}_L = \pm (E\ket{\psi}_L).
    \label{eq:stabcond}
\end{equation}

The action of $E$ changes the codeword to a new eigenstate of the stabilizer generators, where the eigenvalue is still $+1$ for all the generators that commute with $E$, but is $-1$ for those generators that anticommute with $E$.

%The eigenvalue of an operator $M$ from the stabilizer set detects errors which anticommute with $M$.
%On the contrary, if 
The measured eigenvalues $\lambda=\pm 1$ for each generator are called error syndrome.
To extract the syndrome we measure all the observables in the stabilizer. To do this, it is sufficient to measure any set of $n-k$ linearly independent $M$ in $\mathcal{S}$. Note that such a measurement has no effect on a state in the encoded subspace, since it is already an eigenstate of all these observables. 
The measurement projects a noisy state into an eigenstate of each $M$, with eigenvalue $\lambda=\pm 1$.
The error can be deduced from the syndrome, hence, to detect which error affected our logical qubit we need to store the results from the syndrome measurements. 

The syndrome extraction can be done most simply by attaching an $n-k$ qubit ancilla $A$ to the system, and storing in it the eigenvalues. 
 % by a sequence of CNOT gates and Hadamard rotations, such as in the 3 qubit code. However there is a cleveer 

An efficent way to store them is the following:
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{Mainmatter/images/Syndrome_measurement_stabilizer_code.png}
    \caption{Quantum Circuit required to project an arbitrary state, $\ket{\psi}$ into an $\pm 1$ eigenstate of the stabilizer $M$. The measurement result is store then in the ancilla.}
    \label{fig:Syndrome}
\end{figure}


For some arbitrary input state $\ket{\psi}_I$, prepare an ancilla in $(|0\rangle+|1\rangle) / \sqrt{2}$. 
Then, operate controlled-$M$ with ancilla as control, and system as target (We work directly on the encoded state), and then apply an Hadamard rotations on the ancilla. 

After this procedure the final state is: 
\begin{align*}
|\psi\rangle_{F}&=\frac{1}{2}\left(|\psi\rangle_{I}+M|\psi\rangle_{I}\right)|0\rangle+\frac{1}{2}\left(|\psi\rangle_{I}-M|\psi\rangle_{I}\right)|1\rangle \\
&=\frac{1}{2}\left(|\psi\rangle_{I}+\lambda|\psi\rangle_{I}\right)|0\rangle+\frac{1}{2}\left(|\psi\rangle_{I}-\lambda|\psi\rangle_{I}\right)|1\rangle.
\end{align*}
If $M$ is applied on the encoded states it gives or $+1$ or $-1$ as eignestate depending on which error occurred. %It follows that we will measure always $\ket{0}$ in the ancilla if the eigenvalue is $+1$, . 
Hence, if the stabilizer commute with the error ($\lambda=+1$) the ancilla final state will be $\ket{0}$, and viceversa. The syndrome measurements given by the application of the stabilizers are thus stored in the ancilla states. 


The extended network for an error correction code is shown in figure \ref{fig:stab_extract}
\begin{figure}[h!]
    \centering
     \includegraphics[width=\textwidth]{Mainmatter/images/General_stab_Code.png}
     \caption{This figure shows a convenient procedure to extract the syndrome measurements using the stabilizers, which are indicated with $M_i$, and the anchillas without collapsing the initial state. }
     \label{fig:stab_extract}
\end{figure}



Repeating this process for all the $n-k$ operators $M$ which span $\mathcal{S}$, the effect is to couple system with the ancilla as follow \cite{SteaneTut}:
$$
|0\rangle_{a} \sum_{i}\left(E_{i}|\phi\rangle_{L}\right) \rightarrow \sum_{i}\left|s_{i}\right\rangle_{a}\left(E_{i}|\phi\rangle_{L}\right).
$$
The syndromes $s_{i}$ are $(n-k)$ -bit binary strings. So far the treatment is completely general.
Now suppose the $E_{i}$ all have different syndromes. Then a projective measurement of the ancilla will collapse the sum to a single term taken at random: $\left|s_{i}\right\rangle_{a}\left(E_{i}|\phi\rangle_{L}\right)$, and will yield $s_{i}$ as the measurement result. 
The measurement result of the ancilla determines which eigenstate $\ket{\psi}_L$ is projected into.
Since there is only one $E_{i}$ with this syndrome, we can deduce the operator $E_{i}$ and correct it. 

This is the general prescription for correcting errors with a stabilizer code. One measures the values $\pm 1$ of the stabilizer generators; and from the resulting error syndrome, one deduces which error occurred, and correct it (which for Pauli operators means just applying the error again). If the true error operator was actually a linear combination of Pauli operators, measuring the stabilizer generators will project the state into a joint eigenspace, and one proceeds exactly as if the error had been a Pauli operator. Just like linear codes, for a small stabilizer code one can use a look-up table of error syndromes; for a larger code, a decoding algorithm is needed.



Let us see how this works for the bit-flip code. It has generators $g_{1}=Z Z I$ and $g_{2}=I Z Z$. The three weight-one errors are $E_{1}=X I I, E_{2}=I X I, E_{3}=I I X .$ We can see that $E_{1}$ anticommutes with $g_{1}$ and commutes with $g_{2}$ so we will measure the following ancillae: $\ket{0}_{A_1} \ket{1}_{A_2}$; $E_{2}$ anticommutes with both $g_{1}$ and $g_{2}$, with: $\ket{1}_{A_1} \ket{1}_{A_2}$ as ancillae measurement; and $E_{3}$ anticommutes with $g_{2}$ and commutes with $g_{1}$, with  $\ket{1}_{A_1} \ket{0}_{A_2}$ as ancillae measurements. Since $g_{1}$ and $g_{2}$ are commuting observables, we can measure them to diagnose which error happened (or no error). Then, since Pauli operators are unitary and square to the identity, we can then undo the effects of the error by applying the appropriate Pauli operator on the error qubit again.

\section{Quantum code distance} \label{sec:distance}
In general, a quantum correction code can be identified by 3 parameters using the following notation: $[[n, k, d]]$\footnote{The doublebrackets are used simply to denote that the code being referred to is a quantum error correction code rather than a classical code.}. This means that a QECC encodes $k$ logical qubits using $n$ physical qubits , in such a way that any operation which maps some encoded state to another encoded state must act on at least $d$ qubits. 
So far we saw the physical and encoded qubits, but we never focused on the third parameter, so let us define what it is the code distance better, using the stabilizer formalism \cite{gottesman2009introduction} \cite{Gottesman_summer}. 
As shown in the previous chapters, the eigenvalue of an operator $M \in \mathcal{S}$ from the stabilizer detects errors which anticommute with $M$.
On the other hand, if any of those errors which commute with $M$ occurs, the code it is not be able to detects the error anymore. This is because if we measure the eigenvalue of all the generators of the stabilizer they are all still $+1$, and also the correct codeword has eigenvalue $+1$ so there is no way that we can tell if any error occurs. In fact, stabilizer maps codewords in codewords, it is not that we don't measure the right thing actually there is no way to tell. 

In particular let's define a stabilizer set $\mathcal{S}$, and let $\mathrm{T}(\mathrm{S})$ be the corresponding QECC.
Define then,
$$
N(S)=\left\{N \in P_{n} \text { s.t. } M N=N M\quad \forall M \in S\right\},
$$
and errors in this space are undetectable errors. 
Hence, we can say that a general QECC detects any error not in $\mathrm{N}(\mathrm{S}) \backslash \mathrm{S}$ (i.e., errors which commute with the stabilizer are not detected). We need also to remove all the error in $S$ because "errors" in S leave all codewords fixed, so are not really errors (Degenerate QECC, like the Shor code)
In this way, we are left with all those errors which anticommute with some M and can be detected. Starting from this point we can define the distance d. 
The distance d of $\mathrm{T}(\mathrm{S})$ is the weight of the smallest Pauli operator $\mathrm{N}$ in $\mathrm{N}(\mathrm{S}) \backslash \mathrm{S}$.

Intuitively, this can be though as the number of qubit that we need to flip to obtain another codeword. In other words, as is the case for classical codes, the distance of a quantum code is defined as the minimum size error that will go undetected.

This definition of distance tells us not only which errors can be detected but also how many of them can we correct. 
We can tell how many errors the code corrects by looking at operators that commute with the stabilizer. 



We say that a QECC can correct t errors if the set of errors that allow the recovery (those errors not in $\mathrm{N}(\mathrm{S}) \backslash S$) of weight t or less, must satisfy the sufficient conditions for the code to be able to correct the error: 
\begin{equation*}
    \bra{i} E_a^{\dagger}E_b \ket{j} = C_{a,b}\delta_{ij},
\end{equation*}
where $E_a^{\dagger}E_b \notin \mathrm{N}(\mathrm{S}) \backslash S$, and the states $i$ and $j$ are codewords.
%by  $E$ and $F$ if either $E^{\dagger} F \in S$ (so $E$ and $F$ act the same on codewords), or if $\exists M \in S$ s.t. $\left\{M, E^{\dagger} F\right\}=0$, in which case measuring the operator $M$ distinguishes between $E$ and $F$.
%The code correct errors for which $E^{\dagger}F \notin N(S) \backslash S$ for all possible pairs of errors E and F. 

Therefore, to correct t errors, we should look to all these pairs $E_a^\dagger E_b$ that show up in the criterion. Each $E_{a,b}$ acts on t qubit (correspondingly to the weight), but $E_a^\dagger E_b$ acts on $2t$ qubits. Then, the smallest thing in $N(S)\backslash S$ should be at least of weight $2t +1$. 


To sum up, if we want to correct error with  weight t, we need a code distance $d \ge 2t+1$.
Let's take a fast example, (again), the bit-flip code. 
In this code the smallest operator that transform $\ket{0}_L$ to $\ket{1}_L$, or vice versa, it
is $\Bar{X}=X_1X_2X_3$. 
If it were the case that qubits were only susceptible to $X-errors$, then the three-qubit code would have distance $d = 3$, cause each pauli operator has weight $1$
and to obtain another codeword you need 3 of them. 
However, as qubits are also susceptible to phase-flip errors like Z errors. The action of Z maps a codeword to another one, hence, for the bit-flip code a Z error is undetectable. Hence the real distance for this code is $d=1$. 
% In other words, this minimum size error can be viewed as a logical Pauli operator that transforms one codeword state to another. 



% This new eigenstate will always be orthogonal to the original codeword unless the error operator commutes with all the stabilizer generators.
%(So, for example, any encoded state which has been subjected to an error consisting of at most $\lfloor(d-1) / 2\rfloor$ Pauli operations can in principle be recovered perfectly).
%This notation generalises the notation $[n, k, d]$ for classical error correction codes. %in such a way that at least $d$ bits must be flipped to transform between any two codewords representing different plaintexts. (In this context and in the quantum case, $d$ is referred to as the code distance.) 
%
%The distance is the smallest size of a detectable error




\section{Shor QEC code, $[[9,1,3]]$}
The Shor code is an example of a distance-three degenerate code for which it is possible to apply a successful recovery operation for any single-qubit error. This code uses 9-qubits, and it was the first QECCs that was capable of correcting any arbitrary error (Phase and bit flip) on a single qubit, protecting one logical qubit state \cite{Shorfirst}.
The Shor code can be constructed by concatenating the bit-flip code and the phase-flip code. 
Code concatenation involves embedding the output of one code into the input of another.
One can build the encoded Shor states from the codespace of the bit-flip and the phase-flip code. 
Consider the codespace of a single bit-flip code: 
$$
\mathcal{C}_{3b}=\operatorname{span}\left\{|0\rangle_{3b}=|000\rangle,|1\rangle_{3 b}=|111\rangle\right\}, \quad \mathcal{S}_{3 b}=\left\langle Z_{1} Z_{2}, Z_{2} Z_{3}\right\rangle
$$
where $\mathcal{S}_{3b}$ are the code stabilizers. Similarly, codespace for phase-flips $\mathcal{C}_{3 \mathrm{p}}$ is defined
$$
\mathcal{C}_{3 \mathrm{p}}=\operatorname{span}\left\{|0\rangle_{3 \mathrm{p}}=|+++\rangle,|1\rangle_{3 \mathrm{p}}=|---\rangle\right\}, \quad \mathcal{S}_{3 \mathrm{p}}=\left\langle X_{1} X_{2}, X_{2} X_{3}\right\rangle
$$
Then to build the nine-qubit code, the bit-flip code is embedded into the codewords of the phase-flip code. This concatenation maps the $|0\rangle_{3 \mathrm{p}}$ codeword of the phase-flip code to a nine-qubit codeword $|0\rangle_{9}$ as follows
$$
|0\rangle_{3 \mathrm{p}}=|+++\rangle \stackrel{\text { concatenation }}{\longrightarrow}|0\rangle_{9}=|+\rangle_{3 \mathrm{b}}|+\rangle_{3 \mathrm{b}}|+\rangle_{3 \mathrm{b}},
$$
where $|+\rangle_{3 \mathrm{~b}}=\frac{1}{\sqrt{2}}(|000\rangle+|111\rangle)$ is a logical state of the bit-flip code. 

Similarly, the concatenation maps the $|1\rangle_{3 \mathrm{p}}$ codeword of the phase-flip code to
$$
|1\rangle_{3 \mathrm{p}}=|---\rangle \stackrel{\text { concatenation }}{\longrightarrow}|1\rangle_{9}=|-\rangle_{3 \mathrm{~b}}|-\rangle_{3 \mathrm{~b}}|-\rangle_{3 \mathrm{~b}},
$$
where $|-\rangle_{3b}=\frac{1}{\sqrt{\Omega}}(|000\rangle-|111\rangle)$. The code defined by the codewords $|0\rangle_{9}$ and $|1\rangle_{9}$ is the nine-qubit Shor code with paramaters $[[9, 1, 3]]$, and the encoding procedure in a quantum circuit is showed in \ref{fig:Shorenc}. 
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{Mainmatter/images/Shor_enc.png}
    \caption{Quantum circuit that shows the encoding procedure for the Shor code}
    \label{fig:Shorenc}
\end{figure}


Hence, the information qubit $|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$ is encoded in $\left|\psi\right\rangle_{L}=\alpha\left|0\right\rangle_{L}+\beta\left|1\right\rangle_{L}$. 
The codespace basis are: 
\begin{equation*}
\begin{split}
\left|0\right\rangle_{L}=\frac{1}{2 \sqrt{2}}(|000\rangle +|111\rangle) \otimes(|000\rangle +|111\rangle) \otimes(|000\rangle +|111\rangle), \\
\left|1\right\rangle_{L}=\frac{1}{2 \sqrt{2}}(|000\rangle -|111\rangle) \otimes(|000\rangle -|111\rangle) \otimes(|000\rangle -|111\rangle), 
\end{split}
\end{equation*}
Once one has found the codespace, it can also look for a stabilizer set. Since this code is a concatenation of the bit-flip code and the phase-flip code one might use the same stabilizers but with more accuracy. 
A suitable stabilizer set is spanned by: 
\begin{equation}
\begin{aligned}
\mathcal{S}_{[[9,1,3]]}=&\left\langle Z_{1} Z_{2}, Z_{2} Z_{3}, Z_{4} Z_{5}, Z_{5} Z_{6}, Z_{7} Z_{8}, Z_{8} Z_{9}\right.\\
&\left.X_{1} X_{2} X_{3} X_{4} X_{5} X_{6}, X_{4} X_{5} X_{6} X_{7} X_{8} X_{9}\right\rangle.
\end{aligned}
\end{equation}

The first six terms are the stabilizers of the bit-flip codes in the three-blocks of the code. The final two stabilizers derive from the stabilizers of the phase-flip code.

Hence, using the stabiliser formalism we can proceed for the syndrome measurement. 
\begin{table}[h]
    \centering
    \begin{tabular}{cc|cc}
\hline Error & Syndrome, $S$ & Error & Syndrome, $S$ \\
\hline$X_{1}$ & 10000000 & $Z_{1}$ & 00000010 \\
$X_{2}$ & 11000000 & $Z_{2}$ & 00000010 \\
$X_{3}$ & 01000000 & $Z_{3}$ & 00000010 \\
$X_{4}$ & 00100000 & $Z_{4}$ & 00000011 \\
$X_{5}$ & 00110000 & $Z_{5}$ & 00000011 \\
$X_{6}$ & 00010000 & $Z_{6}$ & 00000011 \\
$X_{7}$ & 00001000 & $Z_{7}$ & 00000001 \\
$X_{8}$ & 00001100 & $Z_{8}$ & 00000001 \\
$X_{9}$ & 00000100 & $Z_{9}$ & 00000001 \\
\hline
\end{tabular}
\caption{The syndrome table for single-qubit $X$ and $Z$ errors on the nine-qubit code. The nine-qubit code is a degenerate code, as certain $Z$ errors share the same syndrome}
    \label{tab:stab9}
\end{table}

Table \ref{tab:stab9} shows the syndromes for all single-qubit errors in the nine-qubit code. Each of the $X$ errors produce unique syndromes. In contrast, $Z$ -errors that occur in the same block of the code have the same syndrome. Fortunately, this degeneracy in the code syndromes does not reduce the code distance. To see why this is the case, consider the single-qubit errors $Z_{1}$ and $Z_{2}$, both of which map to the syndrome '00000010'. The decoder therefore has insufficient information to differentiate between the two errors, and will output the same recovery operation for either. For the purposes of this example, we will assume that the recovery operation the decoder outputs is $\mathcal{R}=Z_{1}$. For the case where the error is $E=Z_{1}$, the recovery operation restores the logical state as $\mathcal{R} E|\psi\rangle_{9}=Z_{1} Z_{1}|\psi\rangle_{9}=|\psi\rangle_{9} .$ In the event where $E=Z_{2}$, the recovery operation still restores the logical state as $\mathcal{R} E=Z_{1} Z_{2}$ is in the stabilizer of $\mathcal{C}_{[[9,1,3]]}$, and therefore acts on the logical state as follows $Z_{1} Z_{2}|\psi\rangle_{9}=|\psi\rangle_{9} .$ The same arguments can be applied to the remaining degenerate errors of the code. As a result, the nine-qubit code has the ability to correct all single-qubit errors and has distance $d=3$
In this code the process of correcting a X error or a Z error is totally independent: 
the inner layer of the code corrects bit flip errors taking the majority within each set of three, so 
On the other hand, the outer layer corrects phase flip errors: We take the majority of the three signs,
Since these two error correction steps are independent, the code also works if there is both a bit flip error and a phase flip error, and since $Y = iZX$, a $Y$ error can be thought as a single $X$ error and a single $Z$ error acting on the same qubit, up to an irrelevant global phase.

So this code can correct any Pauli error acting on a single qubit. However, even this is not the limit. Note that any operator on a single qubit can be written as a linear combination $E= aI + bX + cY+dZ$ for some complex numbers $a,b,c,d$. This allow us, using this code, to correct also a continuous tipe of errors. For instance, suppose the action of a general phase error on the codeword: 
$$
R_{\theta / 2}=\left(\begin{array}{cc}
1 & 0 \\
0 & e^{i \theta}
\end{array}\right)=e^{i \theta / 2}\left(\begin{array}{cc}
e^{-i \theta / 2} & 0 \\
0 & e^{i \theta / 2}
\end{array}\right)
$$
(with an overall phase that does not matter), we can write it as
$$
R_{\theta / 2}=\cos \frac{\theta}{2} I-i \sin \frac{\theta}{2} Z .
$$
It turns out that our earlier error correction procedure will also correct this error.
This can suggest a bigger result expressed by the following theorem \cite{DanielGottesman}:

\begin{theorem}
If a quantum code corrects errors A and B, it also corrects any linear combination of A and B. In particular, if it corrects all weight t Pauli errors, then the code corrects all t-qubit errors.
\end{theorem}


\section{CSS codes}
CSS codes are a very special class of stabilizer codes with special properties. In fact, principles from the theory of classical error correction codes can be adapted for the construction of quantum error correction codes. Those quantum error correction codes can be driven from the classical codes and are called CSS codes.
Before introducing a CSS code construction, is better to do a brief recall of classical error correction codes, and we will take the Hamming code as a landmark.
There are two ways of representing a classical linear code and find its codewords: either as the image of a matrix G called the generator matrix or as the kernel of matrix H called the parity check matrix. More precisely we can define a linear classical error correcting code $\mathcal{C}$ of n-bit vectors by: $x \in \mathcal{C} \iff  Hx = 0$ with the linear property: $x,y \in \mathcal{C} \rightarrow x+y \in \mathcal{C}$. Moreover, $HG^T=0$ because each row of the generator matrix is a codeword and must satisfy the parity check; the other codewords are all linear combinations of the rows of the generator matrix.
%Another important definition is the dual code $\mathcal{C}^{\perp}$ of a linear code $\mathcal{C}$, this is the code whose generator matrix is the parity check matrix of $\mathcal{C}$. 
We can deduce a similarity between the parity check matrix and the stabilizer set. 
In fact, in classical codes if an error occur it affects the codeword as follow $x+e_1$ , and no longer satisfy the parity check $H(x+e_1) = He_1 \neq 0$. An analogous situation corresponds when an error occurs and the condition (\ref{eq:stab}) is no longer satisfied.  
Hence, we can see the rows of H as indicators of which stabilizers are needed.
A well known classical correcting code is the Hamming code which is [7,4,3]. The parity check of this code is: 
\begin{equation*}
    H=\left(\begin{array}{ccccccc}
         0&0&0&1&1&1&1 \\
         0&1&1&0&0&1&1 \\
         1&0&1&0&1&0&1 
    \end{array}\right) 
\end{equation*}
If we replace each 1 in this matrix by the operator Z, and 0 by I, we are just specifying three operators that implement the parity check measurements. The statement that the classical Hamming code corrects one error is the statement that each bit flip error of weight one or two anticommutes with one of these three operators.
\begin{equation*}
    H_1=\left(\begin{array}{ccccccc}
         0&0&0&1&1&1&1 \\
         0&1&1&0&0&1&1 \\
         1&0&1&0&1&0&1 
    \end{array}\right) \to \mathcal{S}_{bf}=\left\langle\begin{array}{ccccccc}
         I&I&I&Z&Z&Z&Z  \\
         I&Z&Z&I&I&Z&Z \\
         Z&I&Z&I&Z&I&Z 
    \end{array}\right\rangle
\end{equation*}
However, qubits are subjected to phase-flips as well. We can use again the same procedure; we replace each 1 by X instead of Z and we can correct a phase error. We again get three operators, and they will anticommute with any weight one or two Z error.
\begin{equation*}
    H_2=\left(\begin{array}{ccccccc}
         0&0&0&1&1&1&1 \\
         0&1&1&0&0&1&1 \\
         1&0&1&0&1&0&1
    \end{array}\right) \to \mathcal{S}_{pf}=\left\langle\begin{array}{ccccccc}
         I&I&I&X&X&X&X  \\
         I&X&X&I&I&X&X \\
         X&I&X&I&X&I&X 
    \end{array}\right\rangle
\end{equation*}
Thus, if we make a stabilizer out of the three Z operators and the three X operators, we get a code that can correct any single qubit error. X errors are picked up by the first three generators, Z errors by the last three, and Y errors are distinguished by showing up in both halves. 
\begin{equation}
    \mathcal{S} : \begin{array}{ccccccc}
         I&I&I&Z&Z&Z&Z  \\
         I&Z&Z&I&I&Z&Z \\
         Z&I&Z&I&Z&I&Z \\
         I&I&I&X&X&X&X  \\
         I&X&X&I&I&X&X \\
         X&I&X&I&X&I&X 
         \end{array}
         \label{eq:stabSteane}
\end{equation}
We solved a difficult problem as finding a stabilizer set of a quantum error correcting code with a minimum effort using the knowledge from the classical theory.
But there is one thing that we need to pay attention when we use this procedure: the stabilizer set must be Abelian, i.e. all the elements commute.
In the previous example, the stabilizer set is Abelian and the corresponded code is the Steane code $[[7,1,3]]$.
 
This example uses the same classical code for both the $X$ and $Z$ generators, but there was no reason to do so. We could have used any two classical codes $C_{1}$ and $C_{2}$. The only requirement is that the $X$ and $Z$ generators commute. This corresponds to the statement that $C_{2}^{\perp} \subseteq C_{1}$ where $C_{2}^{\perp}$ is the dual code of $C_{2}$\footnote{$C_2^{\perp}$ is the dual code of $C_2$, intuitively this means that in $C_2^{\perp}$ the generator matrix and the parity matrix are switched respect $C_2$. In other words it consists  of those codewords which are orthogonal to the codewords of $C_{2}$)}.
If $C_{1}$ is an $\left[n, k_{1}, d_{1}\right]$ code, and $C_{2}$ is an $\left[n, k_{2}, d_{2}\right]$ code, then the corresponding quantum code is an $\left[\left[n, k_{1}+k_{2}-n, \min \left(d_{1}, d_{2}\right)\right]\right]$ code. 

   %have a particularly nice form. One way to write down the quantum codewords is:
% $$
% |u\rangle_{L}=\frac{1}{\sqrt{dim(C_2^{\perp})}}\sum_{x \in C_{2}^{\perp}}|x+u \cdot D\rangle
% $$
% where $u$ is a $k$ -bit binary word, $x$ is an $n$ -bit binary word, and $D$ is a $(k \times n)$ matrix of coset leaders. A coset leader is a word of minimum weight in any particular coset, which is a word with the lowest amount of non-zero entries We can understand the structure of these codewords as follows. 
% Start with the case $u=0: |0\rangle_{L}$ is an equal superposition of all the members of $C_{2}^{\perp}.$ 
% The next encoded state is found by displacing all the members of $C_{2}^{\perp}$ by the same vector (the first row of $\left.D\right)$ : in other words we have a superposition of all the members of a coset. We choose the vector (the coset leader) so that this coset is still in $C_{1}$. The other quantum codewords are formed similarly by further cosets of $C_{2}^{\perp}$, all within $C_{1}$. Bit flip correction follows from the%They all must satisfy the same parity checks as the classical code $C_{1}$, so all codewords will be superpositions of codewords of $C_{1} .$ The parity check matrix of $C_{2}$ is the generator matrix of $C_{2}^{\perp}$, so the $X$ generators of the stabilizer add a word of $C_{2}^{\perp}$ to the state. Thus, the codewords of a CSS code are of the form
% $$
% \sum_{w \in C_{2}^{\perp}}|u+w\rangle
% $$
% where $u \in C_{1}\left(C_{2}^{\perp} \subseteq C_{1}\right.$, so $\left.u+w \in C_{1}\right) .$

%The basis of the quantum code 
The codewords of a CSS code, in this case the Steane code, include two entangled states obtained from the classic codewords of each coset of $\mathrm{C}_1$ relative to $\mathrm{C}_2^{\perp}:$ the logical 0 is given from all the codewords with even weight $\mathrm{C}_2^{\perp} \oplus(0000000)$:
% and the $\mathrm{C}^{\perp} \oplus(1111111)=\{$ codewords of $\mathrm{C}$ with odd weight $\}$. The quantum codewords are:

$$
\begin{array}{r}
\left|0\right\rangle_L=\frac{1}{\sqrt{8}}[|0000000\rangle+|1010101\rangle+|0110011\rangle+|1100110\rangle \\
+|0001111\rangle+|1011010\rangle+|0111100\rangle+|1101001\rangle]
\end{array}
$$
To determine the other logical codeword we need to find an element of $C_{1}$ that is not in $C^{\perp}_{2}$. An example of such an element is $(1111111)$, giving then the other logical qubit, which this time is formed by all the codewords with odd weight:
$$
\begin{array}{r}
\left|1\right\rangle_L=\frac{1}{\sqrt{8}}[|1111111\rangle+|0101010\rangle+|1001100\rangle+|0011001\rangle \\
\quad+|1110000\rangle+|0100101\rangle+|1000011\rangle+|0010110\rangle]
\end{array}
$$
\subsection{Simulation of the Seven qubit code}
In this subsection, I will show and discuss the computational results of the seven qubit code. I implemented this code in python, in particular using the qiskit library \cite{Qiskit}. This code can be found in my \href{https://github.com/AlexsashaV4/bachelor_thesis_QEC.git}{GitHub} page as well. 
%%% Encoding
If we want to protect a generic state of information $\ket{\psi}=\alpha\ket{0} + \beta\ket{1}$ we need an encoding procedure. This procedure is based on which stabilizers we are using for the code, in our case we used those showed in \ref{eq:stabSteane}.  
Consider then the bit $q_0$ the "Information qubit" that we wish to protect. 


After some calculations one can find the right encoding procedure, which is shown in figure \ref{fig:Steane_enc}. As result we get the encoded state $\ket{\psi}_L = \alpha \ket{0}_L + \beta \ket{1}_L$.%\footnote{Note: that we don't need an encoded procedure if we wish to transmit the $\ket{0}$ state, this is because $\ket{0}^{\otimes 7}$ is already stabilized by \ref{eq:stabSteane}}
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{Mainmatter/images/Encoding_Seven.png}
    \caption{Encoding procedure for the Steane 7 qubit code}
    \label{fig:Steane_enc}
\end{figure}
%%% Stabilizers


Then, as in 3 qubit code I implemented a gate which simulates an X independently on each qubit with probability $p=0.1$ and a gate which simulates a Z error with the same probability as well. 
After the errors occured I implement the stabiliser measurements with the same scheme of figure \ref{fig:stab_extract}. Consequently the ancilla results are stored in a classical register and based on the bit string of the classical register the error is corrected.
%%% Simulation with bitflip and phase flip 

I decided to illustrate separately the X error and the Z for the Steane code, otherwise, we would have had a histogram with at least 64 ancilla different measurements and too many bars in one chart, that show which of the X, Z or Y error occurred in the simulation.
%Separated because otherwise we would have had 64 ancilla different measurements (and too many bars in one chart)

First, let us discuss the result for the X error simulation. For the sake of simplicity, I used as initial state $q_0=\ket{0}$, and run the simulation $10^4$ times with an error probability of $p=0.1$.
The results are shown in figure \ref{fig:Xerror_Steane}
\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Mainmatter/images/7qubit_Xerrors.png}
    \caption{ This bar graph shows the outcome states and their probabilities from the Steane code simulation with only X errors. On the x-axes, there are the possible measurement outcomes with the ancillas that indicate which error occurred, on the y-axes the associated probability. Along the x-axes, each histogram bar is labelled with the state: $"q_7 q_6 q_5 q_4 q_3 q_2 q_1 q_0  \quad a_2a_1a_0"$, where $a_2a_1a_0$ indicates the ancilla qubit. Is it possible to see the $q_0$ state has been recovered if an error occurred.}
    \label{fig:Xerror_Steane}
\end{figure}

Is it possible to see the $q_0$ state $\ket{0}$ has been recovered if a single error occurred in most cases.  In fact, the first eight columns represent the scenario where only one error occurred and the code detected and corrected it, restoring the original state. 
However, as we can see from figure \ref{fig:Xerror_Steane} there are other smaller bars, which indicate as recovered state not $q_0=\ket{0}$ but $q_0=\ket{1}$. This is associated with the scenario where 2 or more errors occurred, and the code faults in its aim to recover the original information. For example, let us suppose that an X error occurred on qubit $q_2$ and $q_3$ on the encoded state. Then, when we do the stabilizer measurements to detect the error we get the state $\ket{111}$ for the ancillas. When only one error occurs the bit string $'111'$ indicates an error on the qubit $q_6$. In this case, the two errors give the same syndrome, faking an error on the last qubit. For the code, this means to apply anyway a $X$ gate on $q_6$.
This yields a weight 3 error, mapping the original even codeword into an odd codeword. Since odd codeword generates the logical 1, then the decoding procedure yields a wrong result restoring the initial information qubit in the state $\ket{1}$ and not in $\ket{0}$ anymore.




\section{Quantum Hamming bound}
Even if CSS code construction is a very straightforward and elegant procedure, it not guarantees that we can create the best QECC code from classical codes. In fact, exists a better QECC: the $[[5,1,3]]$ \cite{gottesman1997stabilizer}. This code is also a stabilizer code (non-degenerative) and it can be implemented in the same way as the other stabiliser codes by identifying a stabilizer set and the codewords. Can we do better than this? Actually no, there is an upper bound that we cannot cross over if we want to construct an error correction code. This bound is the Hamming bound, which unfortunately only applies to non-degenerate codes, but it gives us an idea of what more general bounds may look like \cite{SteaneTut}.
\renewcommand{\arraystretch}{0.8}
Suppose a non-degenerate code is used to encode $k$ qubits in $n$ physical qubits in such a way that it can correct errors on any subset of $t$ or fewer qubits. Suppose $j$ errors occur, where $j\leq t$. There are $\left(\begin{array}{c}
     n\\
     j
\end{array}\right)$ set of locations where errors may occur. With each such set of locations there are three possible errors (the 3 pauli matrices X,Y,Z) that may occur on a single qubit for a total of $3^j$ possible errors. The total number of errors that may occur on $t$ or fewer qubits is therefore: 
\begin{equation*}
    \sum_{j=0}^t 3^j\left(\begin{array}{c}
     n\\
     j
\end{array}\right)
\end{equation*}
where $j=0$ corresponds to the case where there is no error. In order to encode $k$ qubits in a non-degenerate way each of these errors acting on each basis codeword produces a linearly independent state, must correspond to an orthogonal 2k-dimensional subspace. All these subspaces must be fit in the $2^n$-dimensional available to n qubits, leading to the inequality:
\begin{equation}
    \left(\sum_{j=0}^t 3^j\left(\begin{array}{c}
     n\\
     j
\end{array}\right)\right)2^k \leq 2^n
\label{Hamming}
\end{equation}
This relation is called the quantum Hamming bound. 

To understand the power of this relation consider, for example, the case where we wish to encode one qubit in n qubits in such a way that errors on one qubit are tolerated.
Substituting $t=1,k=1$ in \ref{Hamming}, we obtain the relation: 
\begin{equation*}
    2(1+3n)\leq2^n
\end{equation*}
This is satisfied only for $n\geq 5$.
In fact, the $[[5,1,3]]$ is the best quantum error correction code. There is no code that encodes one qubit in fewer than five qubits in such a way as to protect from all possible errors on a single qubit.
A non-degenerative code for large $n$ and $t$, $R=\frac{k}{n}$ (Rate) fixed the best nondegenerate quantum codes satisfy: 
\begin{equation*}
    \frac{k}{n} \leq 1 - \frac{t}{n}log_2(3) - H\left(\frac{t}{n}\right)
\end{equation*}
where H is the entropy function ($H(x)=-xlog_2(x) -(1-x)log_2(x)$)
The general behaviour hof the hamming bound as a function of $\frac{t}{n}$ is shown in figure \ref{fig:hammingbound}.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.7]{Mainmatter/images/hamming_bound.png}
    \caption{This figure shows the hamming bound. Indicates how many qubit it is possible to encode to correct t errors usin n physical qubit. The dotted and the dashed line are different tipe of bounds \cite{SteaneTut}}.
    \label{fig:hammingbound}
\end{figure}